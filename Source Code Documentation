import numpy as np
import heapq
import random
import time
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import copy

# Set up plotting style
plt.style.use('seaborn-v0_8')

# 1. ENVIRONMENT MODEL
class GridEnvironment:
    """
    Represents a 2D grid environment with:
    - Static obstacles
    - Varying terrain costs
    - Dynamic moving obstacles
    """
    
    def __init__(self, width, height, terrain_costs=None, obstacles=None):
        self.width = width
        self.height = height
        self.terrain_costs = terrain_costs if terrain_costs else np.ones((height, width))
        self.static_obstacles = obstacles if obstacles else set()
        self.dynamic_obstacles = {}  # Format: {obstacle_id: [(time_step, (x,y)), ...]}
        self.packages = []  # List of (start, destination) tuples
        self.agent_start = None
        self.agent_position = None
        
    def add_static_obstacle(self, x, y):
        """Add a static obstacle at position (x, y)"""
        self.static_obstacles.add((x, y))
    
    def add_dynamic_obstacle(self, obstacle_id, path):
        """
        Add a dynamic obstacle that follows a path
        path: list of (time_step, (x, y)) tuples
        """
        self.dynamic_obstacles[obstacle_id] = path
    
    def add_package(self, start, destination):
        """Add a package with start and destination positions"""
        self.packages.append((start, destination))
    
    def set_agent_start(self, position):
        """Set the agent's starting position"""
        self.agent_start = position
        self.agent_position = position
    
    def is_valid_position(self, x, y, time_step=0):
        """Check if a position is valid (within bounds and not blocked)"""
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            return False
        
        # Check static obstacles
        if (x, y) in self.static_obstacles:
            return False
        
        # Check dynamic obstacles at this time step
        for obstacle_path in self.dynamic_obstacles.values():
            for t, pos in obstacle_path:
                if t == time_step and pos == (x, y):
                    return False
        
        return True
    
    def get_terrain_cost(self, x, y):
        """Get the terrain cost at position (x, y)"""
        return self.terrain_costs[y, x]
    
    def get_neighbors(self, x, y, time_step=0):
        """Get valid neighboring positions (4-connected)"""
        neighbors = []
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Up, Right, Down, Left
            nx, ny = x + dx, y + dy
            if self.is_valid_position(nx, ny, time_step):
                neighbors.append((nx, ny))
        return neighbors
    
    def visualize(self, agent_pos=None, packages=None, time_step=0):
        """Visualize the environment"""
        fig, ax = plt.subplots(figsize=(10, 10))
        
        # Create grid visualization
        grid = np.zeros((self.height, self.width))
        
        # Mark static obstacles
        for x, y in self.static_obstacles:
            grid[y, x] = 1
        
        # Mark dynamic obstacles at current time step
        for obstacle_path in self.dynamic_obstacles.values():
            for t, (x, y) in obstacle_path:
                if t == time_step:
                    grid[y, x] = 2
        
        # Mark terrain costs
        terrain_display = np.copy(self.terrain_costs)
        
        # Create colormap
        cmap = plt.cm.viridis
        cmap.set_bad('black', 1.0)  # Black for obstacles
        
        # Create mask for obstacles
        mask = np.zeros_like(grid, dtype=bool)
        mask[grid > 0] = True
        terrain_display = np.ma.masked_where(mask, terrain_display)
        
        # Plot terrain
        im = ax.imshow(terrain_display, cmap=cmap, alpha=0.7)
        plt.colorbar(im, ax=ax, label='Terrain Cost')
        
        # Mark agent position
        if agent_pos:
            ax.plot(agent_pos[0], agent_pos[1], 'ro', markersize=15, label='Agent')
        
        # Mark packages
        if packages:
            for i, (start, dest) in enumerate(packages):
                ax.plot(start[0], start[1], 'bs', markersize=10, label='Package Start' if i == 0 else "")
                ax.plot(dest[0], dest[1], 'g^', markersize=10, label='Package Destination' if i == 0 else "")
        
        # Add grid lines
        ax.set_xticks(np.arange(-0.5, self.width, 1), minor=True)
        ax.set_yticks(np.arange(-0.5, self.height, 1), minor=True)
        ax.grid(which='minor', color='black', linestyle='-', linewidth=0.5)
        ax.tick_params(which='minor', bottom=False, left=False)
        
        ax.set_xlim(-0.5, self.width - 0.5)
        ax.set_ylim(-0.5, self.height - 0.5)
        ax.invert_yaxis()  # To match matrix indexing
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_title(f'Grid Environment (Time Step: {time_step})')
        ax.legend()
        
        plt.tight_layout()
        plt.show()

# 2. SEARCH ALGORITHMS
class SearchAlgorithm:
    """Base class for search algorithms"""
    
    def __init__(self, environment):
        self.env = environment
        self.nodes_expanded = 0
    
    def search(self, start, goal, time_step=0):
        """Perform search from start to goal"""
        raise NotImplementedError
    
    def reconstruct_path(self, came_from, current):
        """Reconstruct the path from start to current node"""
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        path.reverse()
        return path
    
    def get_path_cost(self, path, time_step=0):
        """Calculate the total cost of a path"""
        cost = 0
        for i in range(len(path) - 1):
            x, y = path[i+1]
            cost += self.env.get_terrain_cost(x, y)
        return cost

class BFS(SearchAlgorithm):
    """Breadth-First Search algorithm"""
    
    def search(self, start, goal, time_step=0):
        self.nodes_expanded = 0
        queue = [(start, 0)]  # (position, time_step)
        visited = {start: 0}  # position: time_step
        came_from = {}
        
        while queue:
            current, current_time = queue.pop(0)
            self.nodes_expanded += 1
            
            if current == goal:
                return self.reconstruct_path(came_from, current), current_time
            
            for neighbor in self.env.get_neighbors(current[0], current[1], current_time):
                if neighbor not in visited:
                    visited[neighbor] = current_time + 1
                    came_from[neighbor] = current
                    queue.append((neighbor, current_time + 1))
        
        return None, None  # No path found

class UniformCostSearch(SearchAlgorithm):
    """Uniform Cost Search algorithm"""
    
    def search(self, start, goal, time_step=0):
        self.nodes_expanded = 0
        frontier = [(0, time_step, start)]  # (cost, time_step, position)
        visited = {start: 0}  # position: cost
        came_from = {}
        
        while frontier:
            current_cost, current_time, current = heapq.heappop(frontier)
            self.nodes_expanded += 1
            
            if current == goal:
                return self.reconstruct_path(came_from, current), current_cost
            
            for neighbor in self.env.get_neighbors(current[0], current[1], current_time):
                new_cost = current_cost + self.env.get_terrain_cost(neighbor[0], neighbor[1])
                new_time = current_time + 1
                
                if neighbor not in visited or new_cost < visited[neighbor]:
                    visited[neighbor] = new_cost
                    came_from[neighbor] = current
                    heapq.heappush(frontier, (new_cost, new_time, neighbor))
        
        return None, None  # No path found

class AStarSearch(SearchAlgorithm):
    """A* Search algorithm with admissible heuristic"""
    
    def heuristic(self, a, b):
        """Manhattan distance heuristic (admissible for 4-connected grid)"""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])
    
    def search(self, start, goal, time_step=0):
        self.nodes_expanded = 0
        frontier = [(0, time_step, start)]  # (f_cost, time_step, position)
        g_costs = {start: 0}  # position: g_cost
        came_from = {}
        
        while frontier:
            current_f, current_time, current = heapq.heappop(frontier)
            self.nodes_expanded += 1
            
            if current == goal:
                return self.reconstruct_path(came_from, current), g_costs[current]
            
            for neighbor in self.env.get_neighbors(current[0], current[1], current_time):
                new_g = g_costs[current] + self.env.get_terrain_cost(neighbor[0], neighbor[1])
                new_time = current_time + 1
                
                if neighbor not in g_costs or new_g < g_costs[neighbor]:
                    g_costs[neighbor] = new_g
                    f_cost = new_g + self.heuristic(neighbor, goal)
                    came_from[neighbor] = current
                    heapq.heappush(frontier, (f_cost, new_time, neighbor))
        
        return None, None  # No path found

class HillClimbingSearch(SearchAlgorithm):
    """Hill Climbing with Random Restarts for local search and replanning"""
    
    def __init__(self, environment, max_restarts=10, max_steps=100):
        super().__init__(environment)
        self.max_restarts = max_restarts
        self.max_steps = max_steps
    
    def heuristic(self, a, b):
        """Manhattan distance heuristic"""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])
    
    def get_best_neighbor(self, current, goal, time_step):
        """Find the best neighbor based on heuristic"""
        neighbors = self.env.get_neighbors(current[0], current[1], time_step)
        if not neighbors:
            return None, float('inf')
        
        best_neighbor = None
        best_heuristic = float('inf')
        
        for neighbor in neighbors:
            h = self.heuristic(neighbor, goal)
            if h < best_heuristic:
                best_heuristic = h
                best_neighbor = neighbor
        
        return best_neighbor, best_heuristic
    
    def search(self, start, goal, time_step=0):
        self.nodes_expanded = 0
        best_path = None
        best_cost = float('inf')
        
        for restart in range(self.max_restarts):
            current = start
            current_time = time_step
            path = [current]
            stuck_count = 0
            
            for step in range(self.max_steps):
                self.nodes_expanded += 1
                
                if current == goal:
                    path_cost = self.get_path_cost(path, time_step)
                    if path_cost < best_cost:
                        best_path = path
                        best_cost = path_cost
                    break
                
                best_neighbor, best_h = self.get_best_neighbor(current, goal, current_time)
                
                if best_neighbor is None:
                    break  # No valid neighbors
                
                # Check if we're stuck (no improvement)
                current_h = self.heuristic(current, goal)
                if best_h >= current_h:
                    stuck_count += 1
                    if stuck_count > 5:  # Allow some plateaus
                        # Random restart
                        current = random.choice(list(self.env.get_neighbors(current[0], current[1], current_time)))
                        path.append(current)
                        current_time += 1
                        stuck_count = 0
                        continue
                
                current = best_neighbor
                path.append(current)
                current_time += 1
            
            # Evaluate this path
            if path[-1] == goal:
                path_cost = self.get_path_cost(path, time_step)
                if path_cost < best_cost:
                    best_path = path
                    best_cost = path_cost
        
        return best_path, best_cost if best_path else (None, None)

# 3. DELIVERY AGENT
class DeliveryAgent:
    """Autonomous delivery agent that navigates the grid environment"""
    
    def __init__(self, environment):
        self.env = environment
        self.position = environment.agent_start
        self.time_step = 0
        self.path = []
        self.current_package_index = 0
        self.total_distance = 0
        self.total_cost = 0
        self.log = []
    
    def plan_path(self, start, goal, algorithm, time_step=0):
        """Plan a path using the specified algorithm"""
        if algorithm == 'BFS':
            searcher = BFS(self.env)
        elif algorithm == 'UCS':
            searcher = UniformCostSearch(self.env)
        elif algorithm == 'A*':
            searcher = AStarSearch(self.env)
        elif algorithm == 'HillClimbing':
            searcher = HillClimbingSearch(self.env)
        else:
            raise ValueError(f"Unknown algorithm: {algorithm}")
        
        path, cost = searcher.search(start, goal, time_step)
        nodes_expanded = searcher.nodes_expanded
        
        return path, cost, nodes_expanded
    
    def deliver_packages(self, algorithm='A*', dynamic_replan=False):
        """Deliver all packages using the specified algorithm"""
        self.log.append(f"Starting delivery with {algorithm} algorithm")
        
        for i, (start, destination) in enumerate(self.env.packages):
            self.log.append(f"Picking up package {i+1} from {start}")
            
            # Plan path to package
            path_to_package, cost_to_package, nodes_to_package = self.plan_path(
                self.position, start, algorithm, self.time_step)
            
            if not path_to_package:
                self.log.append(f"ERROR: No path found to package {i+1}")
                return False
            
            # Execute path to package
            for step, pos in enumerate(path_to_package[1:], 1):
                if dynamic_replan and self.check_dynamic_obstacles(pos, self.time_step + step):
                    self.log.append(f"Dynamic obstacle detected at time {self.time_step + step}, replanning...")
                    new_path, new_cost, new_nodes = self.plan_path(
                        self.position, start, algorithm, self.time_step)
                    if new_path:
                        path_to_package = new_path
                        cost_to_package = new_cost
                        nodes_to_package = new_nodes
                        break
            
            self.execute_path(path_to_package)
            self.log.append(f"Picked up package {i+1} at time {self.time_step}")
            
            # Plan path to destination
            path_to_dest, cost_to_dest, nodes_to_dest = self.plan_path(
                self.position, destination, algorithm, self.time_step)
            
            if not path_to_dest:
                self.log.append(f"ERROR: No path found to destination {i+1}")
                return False
            
            # Execute path to destination
            for step, pos in enumerate(path_to_dest[1:], 1):
                if dynamic_replan and self.check_dynamic_obstacles(pos, self.time_step + step):
                    self.log.append(f"Dynamic obstacle detected at time {self.time_step + step}, replanning...")
                    new_path, new_cost, new_nodes = self.plan_path(
                        self.position, destination, algorithm, self.time_step)
                    if new_path:
                        path_to_dest = new_path
                        cost_to_dest = new_cost
                        nodes_to_dest = new_nodes
                        break
            
            self.execute_path(path_to_dest)
            self.log.append(f"Delivered package {i+1} at time {self.time_step}")
            
            # Update statistics
            self.total_distance += len(path_to_package) + len(path_to_dest) - 2  # Exclude start positions
            self.total_cost += cost_to_package + cost_to_dest
        
        self.log.append(f"All packages delivered! Total cost: {self.total_cost}, Total time: {self.time_step}")
        return True
    
    def execute_path(self, path):
        """Execute a path (move the agent along the path)"""
        for pos in path[1:]:  # Skip the first position (current position)
            self.position = pos
            self.time_step += 1
    
    def check_dynamic_obstacles(self, position, time_step):
        """Check if a position will be blocked by a dynamic obstacle at a future time step"""
        for obstacle_path in self.env.dynamic_obstacles.values():
            for t, pos in obstacle_path:
                if t == time_step and pos == position:
                    return True
        return False
    
    def print_log(self):
        """Print the agent's log"""
        for entry in self.log:
            print(entry)
    
    def reset(self):
        """Reset the agent to initial state"""
        self.position = self.env.agent_start
        self.time_step = 0
        self.path = []
        self.current_package_index = 0
        self.total_distance = 0
        self.total_cost = 0
        self.log = []


# 4. TEST MAPS GENERATION

def create_test_maps():
    """Create the required test maps: small, medium, large, and dynamic"""
    
    # Small map (10x10)
    small_map = GridEnvironment(10, 10)
    
    # Add some terrain variation
    small_map.terrain_costs = np.random.randint(1, 4, (10, 10))
    
    # Add static obstacles
    for i in range(3, 7):
        small_map.add_static_obstacle(i, 5)
    
    # Add packages
    small_map.add_package((1, 1), (8, 8))
    small_map.set_agent_start((0, 0))
    
    # Medium map (20x20)
    medium_map = GridEnvironment(20, 20)
    medium_map.terrain_costs = np.random.randint(1, 4, (20, 20))
    
    # Add static obstacles in a maze-like pattern
    for i in range(5, 15):
        medium_map.add_static_obstacle(i, 10)
    for i in range(5, 15):
        medium_map.add_static_obstacle(10, i)
    
    # Add packages
    medium_map.add_package((2, 2), (18, 18))
    medium_map.add_package((15, 3), (5, 15))
    medium_map.set_agent_start((0, 0))
    
    # Large map (30x30)
    large_map = GridEnvironment(30, 30)
    large_map.terrain_costs = np.random.randint(1, 4, (30, 30))
    
    # Add more complex obstacles
    for i in range(5, 25):
        if i % 3 == 0:  # Create gaps
            continue
        large_map.add_static_obstacle(i, 10)
        large_map.add_static_obstacle(i, 20)
    
    # Add packages
    large_map.add_package((2, 2), (28, 28))
    large_map.add_package((25, 5), (5, 25))
    large_map.add_package((15, 15), (20, 10))
    large_map.set_agent_start((0, 0))
    
    # Dynamic map (15x15 with moving obstacles)
    dynamic_map = GridEnvironment(15, 15)
    dynamic_map.terrain_costs = np.random.randint(1, 4, (15, 15))
    
    # Add static obstacles
    for i in range(5, 10):
        dynamic_map.add_static_obstacle(i, 7)
    
    # Add dynamic obstacles (moving vehicles)
    # Obstacle 1: moves horizontally
    obs1_path = [(t, (t % 10 + 2, 5)) for t in range(50)]
    dynamic_map.add_dynamic_obstacle("vehicle1", obs1_path)
    
    # Obstacle 2: moves vertically
    obs2_path = [(t, (8, t % 10 + 2)) for t in range(50)]
    dynamic_map.add_dynamic_obstacle("vehicle2", obs2_path)
    
    # Add packages
    dynamic_map.add_package((1, 1), (13, 13))
    dynamic_map.set_agent_start((0, 0))
    
    return {
        'small': small_map,
        'medium': medium_map,
        'large': large_map,
        'dynamic': dynamic_map
    }

# 5. EXPERIMENTAL FRAMEWORK

def run_experiments():
    """Run experiments comparing all algorithms on all maps"""
    maps = create_test_maps()
    algorithms = ['BFS', 'UCS', 'A*', 'HillClimbing']
    
    results = {}
    
    for map_name, env in maps.items():
        print(f"\n{'='*50}")
        print(f"Testing on {map_name} map ({env.width}x{env.height})")
        print(f"{'='*50}")
        
        results[map_name] = {}
        
        for algorithm in algorithms:
            print(f"\nTesting {algorithm}...")
            
            # Create agent and run delivery
            agent = DeliveryAgent(env)
            start_time = time.time()
            success = agent.deliver_packages(algorithm, dynamic_replan=(algorithm == 'HillClimbing' and map_name == 'dynamic'))
            end_time = time.time()
            
            if success:
                results[map_name][algorithm] = {
                    'success': True,
                    'total_cost': agent.total_cost,
                    'total_time': agent.time_step,
                    'computation_time': end_time - start_time,
                    'log': agent.log
                }
                
                print(f"  Success: True")
                print(f"  Total cost: {agent.total_cost}")
                print(f"  Total time steps: {agent.time_step}")
                print(f"  Computation time: {end_time - start_time:.4f} seconds")
            else:
                results[map_name][algorithm] = {
                    'success': False,
                    'total_cost': float('inf'),
                    'total_time': float('inf'),
                    'computation_time': end_time - start_time,
                    'log': agent.log
                }
                print(f"  Success: False")
    
    return results, maps

def analyze_results(results):
    """Analyze and visualize the experimental results"""
    # Prepare data for visualization
    map_names = list(results.keys())
    algorithms = ['BFS', 'UCS', 'A*', 'HillClimbing']
    
    # Create subplots
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # Plot 1: Total cost comparison
    cost_data = []
    for map_name in map_names:
        map_costs = []
        for algo in algorithms:
            if results[map_name][algo]['success']:
                map_costs.append(results[map_name][algo]['total_cost'])
            else:
                map_costs.append(0)  # Failed runs
        cost_data.append(map_costs)
    
    x = np.arange(len(map_names))
    width = 0.2
    for i, algo in enumerate(algorithms):
        algo_costs = [cost_data[j][i] for j in range(len(map_names))]
        axes[0, 0].bar(x + i*width, algo_costs, width, label=algo)
    
    axes[0, 0].set_xlabel('Map')
    axes[0, 0].set_ylabel('Total Cost')
    axes[0, 0].set_title('Total Cost Comparison')
    axes[0, 0].set_xticks(x + width*1.5)
    axes[0, 0].set_xticklabels(map_names)
    axes[0, 0].legend()
    
    # Plot 2: Computation time comparison
    time_data = []
    for map_name in map_names:
        map_times = []
        for algo in algorithms:
            map_times.append(results[map_name][algo]['computation_time'])
        time_data.append(map_times)
    
    for i, algo in enumerate(algorithms):
        algo_times = [time_data[j][i] for j in range(len(map_names))]
        axes[0, 1].bar(x + i*width, algo_times, width, label=algo)
    
    axes[0, 1].set_xlabel('Map')
    axes[0, 1].set_ylabel('Computation Time (seconds)')
    axes[0, 1].set_title('Computation Time Comparison')
    axes[0, 1].set_xticks(x + width*1.5)
    axes[0, 1].set_xticklabels(map_names)
    axes[0, 1].legend()
    
    # Plot 3: Success rate
    success_rates = []
    for algo in algorithms:
        successes = sum(1 for map_name in map_names if results[map_name][algo]['success'])
        success_rates.append(successes / len(map_names))
    
    axes[1, 0].bar(algorithms, success_rates, color=['green' if rate > 0.5 else 'red' for rate in success_rates])
    axes[1, 0].set_xlabel('Algorithm')
    axes[1, 0].set_ylabel('Success Rate')
    axes[1, 0].set_title('Success Rate by Algorithm')
    
    # Plot 4: Performance summary table
    table_data = []
    for map_name in map_names:
        row = []
        for algo in algorithms:
            if results[map_name][algo]['success']:
                row.append(f"Cost: {results[map_name][algo]['total_cost']}\nTime: {results[map_name][algo]['computation_time']:.3f}s")
            else:
                row.append("Failed")
        table_data.append(row)
    
    axes[1, 1].axis('off')
    table = axes[1, 1].table(cellText=table_data, 
                            rowLabels=map_names, 
                            colLabels=algorithms,
                            loc='center',
                            cellLoc='center')
    table.auto_set_font_size(False)
    table.set_fontsize(8)
    table.scale(1, 2)
    axes[1, 1].set_title('Detailed Results')
    
    plt.tight_layout()
    plt.show()
    
    # Print analysis
    print("\n" + "="*60)
    print("ANALYSIS OF RESULTS")
    print("="*60)
    
    for algo in algorithms:
        print(f"\n{algo} Analysis:")
        
        # Calculate average performance metrics
        successful_costs = [results[map_name][algo]['total_cost'] 
                           for map_name in map_names 
                           if results[map_name][algo]['success']]
        avg_cost = np.mean(successful_costs) if successful_costs else float('inf')
        
        avg_time = np.mean([results[map_name][algo]['computation_time'] 
                          for map_name in map_names])
        
        success_rate = np.mean([1 if results[map_name][algo]['success'] else 0 
                              for map_name in map_names])
        
        print(f"  Average Cost: {avg_cost:.2f}")
        print(f"  Average Computation Time: {avg_time:.4f} seconds")
        print(f"  Success Rate: {success_rate*100:.1f}%")
        
        # Strengths and weaknesses
        if algo == 'BFS':
            print("  Strengths: Guaranteed optimal path (in steps), simple implementation")
            print("  Weaknesses: High memory usage, ignores terrain costs")
        elif algo == 'UCS':
            print("  Strengths: Guaranteed optimal path (in cost), considers terrain")
            print("  Weaknesses: Higher computation time than A*")
        elif algo == 'A*':
            print("  Strengths: Efficient, optimal with admissible heuristic")
            print("  Weaknesses: Heuristic quality affects performance")
        elif algo == 'HillClimbing':
            print("  Strengths: Fast for simple problems, good for dynamic replanning")
            print("  Weaknesses: Can get stuck in local optima, not guaranteed optimal")

# 6. DEMONSTRATIONS
def demonstrate_dynamic_replanning():
    """Demonstrate dynamic replanning with a visual animation"""
    # Create a dynamic map
    env = GridEnvironment(10, 10)
    env.terrain_costs = np.ones((10, 10))
    
    # Add a dynamic obstacle that blocks the path
    obstacle_path = [(t, (5, t//2)) for t in range(20)]  # Moves down
    env.add_dynamic_obstacle("blocker", obstacle_path)
    
    # Add a package
    env.add_package((0, 0), (9, 9))
    env.set_agent_start((0, 0))
    
    # Create agent
    agent = DeliveryAgent(env)
    
    # Plan initial path
    path, cost, nodes = agent.plan_path((0, 0), (9, 9), 'A*', 0)
    
    print("Initial path planned by A*:")
    print(path)
    
    # Simulate movement with dynamic replanning
    fig, ax = plt.subplots(figsize=(8, 8))
    
    def animate(frame):
        ax.clear()
        
        # Visualize environment at current time
        grid = np.ones((10, 10))
        
        # Mark dynamic obstacle
        for t, (x, y) in env.dynamic_obstacles["blocker"]:
            if t == frame:
                grid[y, x] = 0  # Obstacle
        
        # Plot grid
        im = ax.imshow(grid, cmap='RdYlGn', vmin=0, vmax=1)
        
        # Plot agent position if it has moved
        if frame < len(path):
            ax.plot(path[frame][0], path[frame][1], 'bo', markersize=15, label='Agent')
        
        ax.set_xlim(-0.5, 9.5)
        ax.set_ylim(-0.5, 9.5)
        ax.invert_yaxis()
        ax.set_title(f'Dynamic Replanning Demonstration\nTime Step: {frame}')
        ax.legend()
        
        # Add grid lines
        ax.set_xticks(np.arange(-0.5, 10, 1), minor=True)
        ax.set_yticks(np.arange(-0.5, 10, 1), minor=True)
        ax.grid(which='minor', color='black', linestyle='-', linewidth=0.5)
        ax.tick_params(which='minor', bottom=False, left=False)
    
    # Create animation
    anim = FuncAnimation(fig, animate, frames=20, interval=500, repeat=False)
    plt.close()
    
    # Display animation
    return HTML(anim.to_jshtml())

def demonstrate_hill_climbing_replanning():
    """Demonstrate hill climbing with random restarts for dynamic obstacles"""
    # Create an environment with a dynamic obstacle
    env = GridEnvironment(8, 8)
    env.terrain_costs = np.random.randint(1, 3, (8, 8))
    
    # Add a dynamic obstacle that appears suddenly
    obstacle_path = [(5, (4, 4)), (6, (4, 4)), (7, (4, 4))]  # Appears at time 5
    env.add_dynamic_obstacle("sudden", obstacle_path)
    
    # Add a package
    env.add_package((1, 1), (6, 6))
    env.set_agent_start((0, 0))
    
    # Create agent and run with hill climbing
    agent = DeliveryAgent(env)
    success = agent.deliver_packages('HillClimbing', dynamic_replan=True)
    
    print("Hill Climbing with Dynamic Replanning Log:")
    print("-" * 50)
    agent.print_log()
    
    # Visualize the final path
    env.visualize(agent.position, env.packages, agent.time_step)
    
    return success

def main():
    """Main function to run the complete project"""
    print("Autonomous Delivery Agent Project")
    print("=" * 50)
    
    # Create test maps
    print("Creating test maps...")
    maps = create_test_maps()
    
    # Visualize the maps
    for map_name, env in maps.items():
        print(f"\nVisualizing {map_name} map:")
        env.visualize(env.agent_start, env.packages)
    
    # Run experiments
    print("\nRunning experiments...")
    results, maps = run_experiments()
    
    # Analyze results
    print("\nAnalyzing results...")
    analyze_results(results)
    
    # Demonstrate dynamic replanning
    print("\nDemonstrating dynamic replanning...")
    anim = demonstrate_dynamic_replanning()
    display(anim)
    
    # Demonstrate hill climbing with random restarts
    print("\nDemonstrating hill climbing with dynamic replanning...")
    demonstrate_hill_climbing_replanning()

# 7. MAIN EXECUTION
# Run the main function
if __name__ == "__main__":
    main()

# COMMAND LINE INTERFACE (CLI) FOR RUNNING PLANNERS
def run_planner_cli():
    """Command Line Interface for running different planners"""
    print("=" * 60)
    print("AUTONOMOUS DELIVERY AGENT - PLANNER CLI")
    print("=" * 60)
    
    # Create test maps
    maps = create_test_maps()
    
    while True:
        print("\nAvailable Maps:")
        for i, map_name in enumerate(maps.keys(), 1):
            print(f"{i}. {map_name} ({maps[map_name].width}x{maps[map_name].height})")
        
        print("\nAvailable Algorithms:")
        algorithms = ['BFS', 'UCS', 'A*', 'HillClimbing']
        for i, algo in enumerate(algorithms, 1):
            print(f"{i}. {algo}")
        
        print("\nOptions:")
        print("1. Run single algorithm on specific map")
        print("2. Run all algorithms on specific map") 
        print("3. Run comprehensive experiments (all algorithms on all maps)")
        print("4. Demonstrate dynamic replanning")
        print("5. Exit")
        
        choice = input("\nEnter your choice (1-5): ").strip()
        
        if choice == '1':
            # Single algorithm on specific map
            map_choice = input("Select map (1-4): ").strip()
            algo_choice = input("Select algorithm (1-4): ").strip()
            
            try:
                map_name = list(maps.keys())[int(map_choice)-1]
                algorithm = algorithms[int(algo_choice)-1]
                
                env = maps[map_name]
                agent = DeliveryAgent(env)
                
                print(f"\nRunning {algorithm} on {map_name} map...")
                start_time = time.time()
                success = agent.deliver_packages(algorithm, dynamic_replan=(algorithm=='HillClimbing'))
                end_time = time.time()
                
                if success:
                    print(f"✓ Delivery completed successfully!")
                    print(f"  Total cost: {agent.total_cost}")
                    print(f"  Total time steps: {agent.time_step}")
                    print(f"  Computation time: {end_time - start_time:.4f}s")
                    
                    # Show final state
                    env.visualize(agent.position, env.packages, agent.time_step)
                else:
                    print("✗ Delivery failed - no path found")
                    
            except (ValueError, IndexError):
                print("Invalid input! Please try again.")
                
        elif choice == '2':
            # All algorithms on specific map
            map_choice = input("Select map (1-4): ").strip()
            
            try:
                map_name = list(maps.keys())[int(map_choice)-1]
                env = maps[map_name]
                
                print(f"\nRunning all algorithms on {map_name} map...")
                results = {}
                
                for algorithm in algorithms:
                    print(f"\n--- Testing {algorithm} ---")
                    agent = DeliveryAgent(env)
                    start_time = time.time()
                    success = agent.deliver_packages(algorithm, dynamic_replan=(algorithm=='HillClimbing'))
                    end_time = time.time()
                    
                    if success:
                        results[algorithm] = {
                            'cost': agent.total_cost,
                            'time_steps': agent.time_step,
                            'computation_time': end_time - start_time
                        }
                        print(f"✓ Success - Cost: {agent.total_cost}, Time: {agent.time_step} steps")
                    else:
                        results[algorithm] = {'cost': 'Failed', 'time_steps': 'Failed'}
                        print("✗ Failed")
                
                # Display results table
                print(f"\n{'Algorithm':<12} {'Cost':<10} {'Time Steps':<12} {'Comp Time (s)':<15}")
                print("-" * 50)
                for algo, result in results.items():
                    if result['cost'] != 'Failed':
                        print(f"{algo:<12} {result['cost']:<10} {result['time_steps']:<12} {result['computation_time']:<15.4f}")
                    else:
                        print(f"{algo:<12} {'Failed':<10} {'Failed':<12} {'N/A':<15}")
                        
            except (ValueError, IndexError):
                print("Invalid input! Please try again.")
                
        elif choice == '3':
            # Comprehensive experiments
            print("\nRunning comprehensive experiments...")
            results, _ = run_experiments()
            analyze_results(results)
            
        elif choice == '4':
            # Dynamic replanning demonstration
            print("\nDemonstrating dynamic replanning...")
            anim = demonstrate_dynamic_replanning()
            display(anim)
            demonstrate_hill_climbing_replanning()
            
        elif choice == '5':
            print("Exiting CLI. Goodbye!")
            break
            
        else:
            print("Invalid choice! Please enter 1-5.")

# Add this to main() function
def main():
    """Execute complete project with CLI option"""
    print("Autonomous Delivery Agent Project")
    print("=" * 50)
    print("Choose execution mode:")
    print("1. Full automated demonstration")
    print("2. Interactive CLI mode")
    
    choice = input("Enter choice (1 or 2): ").strip()
    
    if choice == '1':
        # Original automated execution
        maps = create_test_maps()
        for map_name, env in maps.items():
            env.visualize(env.agent_start, env.packages)
        
        results, maps = run_experiments()
        analyze_results(results)
        
        anim = demonstrate_dynamic_replanning()
        display(anim)
        demonstrate_hill_climbing_replanning()
        
    elif choice == '2':
        # CLI mode
        run_planner_cli()
    else:
        print("Invalid choice! Running full demonstration.")
        # Run full demonstration as fallback

